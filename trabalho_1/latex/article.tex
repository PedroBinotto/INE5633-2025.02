\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[a4paper, left=3cm, right=2cm, top=3cm, bottom=2cm]{geometry}
\usepackage[dvipsnames]{xcolor}
\usepackage[toc]{glossaries}
\usepackage{authblk}
\usepackage{cite}
\usepackage{fontspec}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{relsize}
\usepackage{setspace}
\usepackage{subcaption}
\usepackage{verbatimbox}
\usepackage[english, portuguese]{babel}
    \addto\captionsportuguese{\renewcommand*\bibname{Referências}}
    \addto\captionsportuguese{\renewcommand*\contentsname{Sumário}}

\newcommand\myshade{85}
\newcommand{\pprime}{\ensuremath{^{\prime}}}
\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}}
\renewcommand\Authsep{, }
\renewcommand\Authand{, }
\renewcommand\Authands{, e }
\providecommand{\keywords}[1]{%
  \small
  \textbf{\textit{\iflanguage{english}{Keywords}{Palavras-chave} ---}} #1%
}

\hypersetup{
    pdftitle   = {Título de Artigo, Subtítulo de Artigo},
    pdfauthor  = {Pedro Santi Binotto},
    pdfsubject = {Resumo em Português},
    linkcolor  = black,
    citecolor  = black,
    urlcolor   = black,
    colorlinks = true,
    filecolor  = black,
    linktoc    = page
}%

\lstset{
    language=Python,
    backgroundcolor=\color{white},
    basicstyle=\ttfamily\small\color{black},
    commentstyle=\color{gray}\textit,
    keywordstyle=\color{MidnightBlue}\bfseries,
    stringstyle=\color{OliveGreen},
    numbers=left,
    numberstyle=\tiny\color{darkgray},
    breaklines=true,
    frame=single,
    rulecolor=\color{lightgray},
    captionpos=b,
}

% \newglossaryentry{gls} {
%   name={GLS},
%   description={Glossary entry}
% }

\title{Atividade Prática \RNum{1} \\ [0.2em]\smaller{}Trabalho sobre Métodos de busca}

\author[1]{Pedro Santi Binotto [20200634]\thanks{\texttt{pedro.binotto@grad.ufsc.br}}}
\author[2]{Cauã Pablo Padilha [22100895]\thanks{\texttt{padilha.caua@grad.ufsc.br}}}
\author[3]{Felipe Jun Hatsumura [19206699]\thanks{\texttt{fjhats@gmail.com}}}
\author[4]{Gabriel Lemos da Silva [18200628]\thanks{\texttt{glemoss.dev@gmail.com}}}
\date{\today}
\affil[1]{Departamento de Informática e Estatística, Universidade Federal de Santa Catarina}

\makeglossaries

\begin{document}
\begin{titlepage}
\selectlanguage{portuguese} 
\maketitle
\thispagestyle{empty}

\end{titlepage}

\tableofcontents

\printglossary[title=Glossário, toctitle=Glossário]

\newpage

\section{Q1}

\paragraph{Proposta ---} enunciado na \textit{Questão 1}:

\begin{quote}
Quais os métodos ou funções principais e suas relações com o algoritmo A*?
\end{quote}

\subsubsection{Solução --- \textbf{Q1}}

\paragraph{I/O}
Primeiramente, os dados de entrada do programa são lidos e interpretados pela função \texttt{capture\_input}. Os dados deverão ser informados no seguinte formato:

\begin{verbatim}
M
E0..EN
LEVEL
\end{verbatim}

Onde:
\begin{itemize}
  \item \textit{M} refere-se ao tamanho (do lado) do tabuleiro (ex.: 3 para \textit{8Puzzle} , 4 para \textit{15Puzzle}, etc...);
\item \textit{E0..EN} referem-se aos números de ($N = M^2$) de 0 até \textit{N} (em qualquer ordem) que expressam o estado inicial do tabuleiro;
\item \textit{LEVEL} é um valor dentre:
  \begin{itemize}
    \item \textbf{\texttt{L0:}} Para execução de \textit{A*} com heurística \textit{nula} (custo uniforme);
      \item \textbf{\texttt{L1:}} Para execução de \textit{A*} com heurística não admissível;
      \item \textbf{\texttt{L2:}} Para execução de \textit{A*} com heurística \textit{Manhattan\cite{sharma2016}};
      \item \textbf{\texttt{L3:}} Para execução de \textit{A*} com heurística tunada;
  \end{itemize}
\end{itemize}

\paragraph{}
À partir destes dados, serão produzidas as seguintes estruturas de dados, que possibilitarão o processamento do \textit{puzzle}:

\begin{itemize}
\item \textbf{\texttt{g}} - Grafo que serve de estrutura de dados para o algoritmo, contendo apenas o estado inicial
\item \textbf{\texttt{n}} - Tamanho do tabuleiro
\item \textbf{\texttt{s}} - Estado inicial
\item \textbf{\texttt{t}} - Estado alvo
\item \textbf{\texttt{l}} - Heurística a ser utilizada
\end{itemize}

\paragraph{A*}
A função de busca (implementada sob \texttt{a\_star(g, n, s, t, h)}) recebe, então, estes dados, e inicia o
processamento a partir do nó \texttt{s} (estado inicial informado ao programa):

\begin{lstlisting}[language=python]
def a_star(
    g: Graph, n: int, s: State, t: State, h: HeuristicFunction, max_nodes: int = 400_000
) -> Result | None:
    """
    'A*' search algorithm
    ...
    """"
\end{lstlisting}

Deste ponto em diante, o algoritmo de busca irá calcular para cada nó (nó da vez) as possibilidades de movimentos
alcançáveis a partir do da configuração atual do tabuleiro, similarmente a uma busca em largura (\textit{BFS}), porém
utilizando uma fila priorizada (\textit{Priority Queue}) baseada no \textit{score} de cada movimento, que será referente
à função \textit{f}:

\begin{displaymath}
f(n) = g(n) + h(n)
\end{displaymath}

Onde:
\begin{itemize}
  \item $f(n)$ é o \textit{score} geral;
  \item $g(n)$ é o valor de \textit{custo} ou \textit{função utilidade} atrelada ao nó;
  \item $h(n)$ é o valor de \textit{heurístico} atrelado ao nó;
\end{itemize}

\paragraph{}
O algoritmo navegará o grafo seguindo a ordem da fila priorizada até encontrar o estado de solução (\texttt{t}) ou a
fila ficar vazia, que sinalizará que o estado de entrada (\texttt{s}) não é solucionável.

\paragraph{Observação}
Deve ser observado que a implementação de \texttt{a\_star} recebe também um sexto parâmetro ``\texttt{max\_nodes}'', que
agirá como uma salvaguarda, para evitar que, em casos de \textit{puzzles} maiores (\textit{15Puzzle},
\textit{24Puzzle}), o programa consuma muita memória do \textit{host}, abortando a busca uma vez que este limite é
atingido.

\newpage

\section{Q2}

\paragraph{Proposta ---} enunciado na \textit{Questão 2}:

\begin{quote}
Como foi gerenciada a fronteira, ou seja, quais verificações foram feitas antes de adicionar um estado na fronteira? Explicar e mostrar os respectivos trechos de código:
\end{quote}

\subsubsection{Solução --- \textbf{Q2}}

\paragraph{}
A fronteira é gerenciada com uma fila priorizada (\textit{Priority Queue}), inicializada com o estado inicial $\left[ \left( h(s, t, n), g(s), s \right) \right]$:

Onde:
\begin{itemize}
  \item $s$ é a representação do estado referente ao score, na forma de uma tupla ordenada;
  \item $t$ é a representação do estado solução, que representa o objetivo da busca;
  \item $n$ é o tamanho de lado do tabuleiro;
  \item $g(n)$ é inicializado em 0;
  \item $h(n)$ é o resultado da função heurística sobre $s, t, n$;
\end{itemize}

\begin{lstlisting}[language=python]
visited_nodes: set[State] = set()
priority_queue: list[tuple[int, int, State]] = [(h(s, t, n), NODE_MIN_SCORE, s)]
upper_bound = len(priority_queue)
breadcrumb: Breadcrumb = {}
gs: dict[State, int] = {s: NODE_MIN_SCORE}
\end{lstlisting}

\paragraph{}
Estruturas de controle:

\begin{itemize}
  \item \textbf{\texttt{visited\_nodes}}: Conjunto que armazena estados já expandidos/visitados;
  \item \textbf{\texttt{priority\_queue}}: Estrutura que mantém a fronteira (nós abertos), ordenada pelo valor de $f(n)$;
  \item \textbf{\texttt{upper\_bound}}: Limite superior do tamanho da fronteira (para estatísticas);
  \item \textbf{\texttt{breadcrumb}}: Grafo mínimo que mantém as relações inversas da árvore principal, utilizado para
    retraçar o caminho escolhido de forma mais econômica em relação à memória;
  \item \textbf{\texttt{gs}}: Dicionário que armazena o menor custo de utilidade conhecido referente à cada estado;
\end{itemize}

\paragraph{}
Nós que já constam em \texttt{visited\_nodes} são ignorados afim de evitar a formação de ciclos no grafo.

\begin{lstlisting}[language=python]
while priority_queue:
...
    curr_h, curr_g, curr_s = pq_pop(priority_queue)

    if curr_s == t:
        return ...

    if curr_s in visited_nodes:
        continue
    visited_nodes.add(curr_s)
\end{lstlisting}

\paragraph{}
Os ``filhos'' de cada nó são então calculados e explorados (via busca em largura) e submetidos às funções de score e
fila priorizada; as métricas como \texttt{upper\_bound} também são atualizadas:

\begin{lstlisting}[language=Python]
for move in compute_moves(curr_s, n):
    g.add_edge(curr_s, move)
    next_g = curr_g + 1
    if move in visited_nodes and next_g >= gs.get(move, NODE_MAX_SCORE):
        continue

    if next_g < gs.get(move, NODE_MAX_SCORE):
        breadcrumb[move] = curr_s
        gs[move] = next_g
        f_neighbor = next_g + h(move, t, n)
        pq_push(priority_queue, (f_neighbor, next_g, move))
        if len(priority_queue) > upper_bound:
            upper_bound = len(priority_queue)
\end{lstlisting}

\newpage

\section{Q3}

\paragraph{Proposta ---} enunciado na \textit{Questão 3}:

\begin{quote}
Descrição das heurísticas e comparação da faixa de valores e da precisão delas (no mínimo: dois casos difíceis, dois médios e um fácil); breve descrição sobre suas implementações.
\end{quote}

\subsubsection{Solução --- \textbf{Q3}}

Para atender os requisitos do trabalho foram feitas três heurísticas e o algoritmo sem heurísticas (custo uniforme – L0). As heurísticas escolhidas foram:

\begin{itemize}
    \item \textbf{Heurística não admissível (L1)} - \textit{Manhattan} x 2
    \item \textbf{Heurística admissível (L2)} - \textit{Manhattan}
    \item \textbf{Melhor Heurística admissível (L3)} - \textit{Manhattan} + Conflitos Lineares
\end{itemize}

A heurística de \textit{Manhattan} calcula a distância em que cada peça está posicionada e da sua posição destino (a posição correta) sem considerar as diagonais, portanto considerando deslocamentos apenas na vertical e horizontal \cite{sharma2016}. Essa heurística utilizada é considerada admissível pois não superestima o custo real, porém utilizá-la com o valor dobrado a torna não admissível pois superestima o custo real.

A utilização de \textit{Manhattan} + Conflitos Lineares foi escolhida como a melhor heurística possível pois considera a distância de \textit{Manhattan}, explicada anteriormente, e também leva em consideração a quantidade de peças na linha ou coluna correta mas em posição errada.

\paragraph{Apontamentos}
\begin{itemize}
  \item Custo uniforme sempre retornará $h(n) = 0$. Essa heurística fará a busca baseada apenas em $g(n)$ e explora
    muito mais estados, se não, todos;
  \item A heurística de \textit{Manhattan} calcula a distância em que cada peça está posicionada e da sua posição
    destino (a posição correta) sem considerar as diagonais, portanto considerando deslocamentos apenas na vertical e
    horizontal. Essa heurística utilizada é considerada admissível pois não superestima o custo real, porém utilizá-la
    com o valor dobrado a torna não admissível pois superestima o custo real\cite{sharma2016};
  \item A heurística não admissível irá retornar $h(n) * 2$; Isso superestima o custo real e pode otimizar o tempo de
    execução da busca, porém, retornando um caminho não perfeito;
  \item A utilização de \textit{Manhattan} + Conflitos Lineares foi escolhida como a melhor heurística possível pois considera a distância de \textit{Manhattan}, explicada anteriormente, e também leva em consideração a quantidade de peças na linha ou coluna correta mas em posição errada. Essa heurística ainda é admissível.
\end{itemize}

\newpage

\section{Q4}\label{sec:q4}

\paragraph{Proposta ---} enunciado na \textit{Questão 4}:

\begin{quote}
Breve análise do desempenho da implementação com uma tabela comparativa (usando as informações da saída - itens a) a d)) das 4 variações implementadas (no mínimo: um caso difícil, um médio e um fácil para as abordagens 3 e 4 e um médio e um fácil para as abordagens 1 e 2):
\end{quote}

\subsubsection{Solução --- \textbf{Q4}}

\begin{table}[h]
  \caption{8Puzzle}\label{tab:8p}
  \centering
  \resizebox{\textwidth}{!}{%
    \begin{tabular}{c|c|c|c|c|c|c}
      \hline
        Nível Heurística & Dificuldade & Instância & Tempo (segundos) & Nós Visitados & Máx. Fronteira & Caminho \\
      \hline
        L0 & Fácil & pzzl\_0\_8 & 0.517 & 8163 & 4485 & 17 \\
        L0 & Médio & pzzl\_3\_8 & 0.036 & 8164 & 4485 & 17 \\
        L1 & Fácil & pzzl\_0\_8 & 0.001 & 154 & 99 & 17 \\
        L1 & Médio & pzzl\_3\_8 & 0.0008 & 127 & 81 & 19 \\
        L2 & Fácil & pzzl\_0\_8 & 0.0009 & 194 & 121 & 17 \\
        L2 & Médio & pzzl\_3\_8 & 0.001 & 202 & 126 & 17 \\
        L2 & Difícil & pzzl\_7\_8 & 0.0003 & 47 & 37 & 13 \\
        L3 & Fácil & pzzl\_0\_8 & 0.001 & 117 & 79 & 17 \\
        L3 & Médio & pzzl\_3\_8 & 0.002 & 126 & 83 & 17 \\
        L3 & Difícil & pzzl\_7\_8 & 0.0006 & 31 & 24 & 13 \\
      \hline
    \end{tabular}
    }
\end{table}


\begin{table}[h]
  \caption{15Puzzle}\label{tab:15p}
  \centering
  \resizebox{\textwidth}{!}{%
    \begin{tabular}{c|c|c|c|c|c|c}
      \hline
        Heurística & Dificuldade & Instância & Tempo (s) & Nós Visitados & Fronteira Max & Tamanho Caminho \\
      \hline
        L0 & Fácil & pzzl\_0\_15 & 3.23 & 400000 & 378572 & N/A \\
        L0 & Médio & pzzl\_3\_15 & 3.21 & 400000 & 378572 & N/A \\
        L1 & Fácil & pzzl\_0\_15 & 4.69 & 400000 & 357639 & N/A \\
        L1 & Médio & pzzl\_3\_15 & 4.72 & 400000 & 351535 & N/A \\
        L2 & Fácil & pzzl\_0\_15 & 4.79 & 400000 & 347360 & N/A \\
        L2 & Médio & pzzl\_3\_15 & 4.75 & 400000 & 353335 & N/A \\
        L2 & Difícil & pzzl\_7\_15 & 4.98 & 400000 & 358550 & N/a \\
        L3 & Fácil & pzzl\_0\_15 & 9.83 & 400000 & 344200 & N/A \\
        L3 & Médio & pzzl\_3\_15 & 10.37 & 400000 & 360985 & N/A \\
        L3 & Difícil & pzzl\_7\_15 & 10.52 & 400000 & 361953 & N/A \\
      \hline
    \end{tabular}
    }
\end{table}

\newpage

\section{Q5}

\paragraph{Proposta ---} enunciado na \textit{Questão 5}:

\begin{quote}
Caso algum dos objetivos não tenha sido alcançado explique o que você faria VS o que foi feito e exatamente qual o(s)
  problema(s) encontrado(s), bem como  limitações da implementação:
\end{quote}

\subsubsection{Solução --- \textbf{Q5}}

\paragraph{}
Para os \textit{puzzles} maiores ($4^2$, $5^2$), não foi possível fazer uma leitura exata das versões mais
rudimentares/menos eficientes da busca (custo uniforme ou heurística não admissível), como a complexidade de tempo e
memória era alta demais e o hardware não era capaz de encontrar a solução nestes casos. 

Por este motivo, adicionamos um
parâmetro de ``\texttt{max\_nodes}'' (\textit{default: 400000 nós}) à função de busca, que determina um número máximo de nós que podem ser explorados
antes de abortar a operação, afim de evitar situações que resultariam no congelamento do sistema \textit{host}, como
aconteceu algumas vezes em desenvolvimento.

Assim, observa-se na \nameref{sec:q4} que alguns dados nas tabelas estão ausentes, pois não conseguimos produzir um
resultado satisfatório --- isto é, uma solução para o \textit{puzzle}.

Não identificamos se isso é indicativo de um problema na implementação das nossas heurísticas ou uma questão de ordem de
magnitude.

\newpage
\section{Bibliografia}
\bibliographystyle{plain}
\bibliography{references}

\end{document}

